<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.ico">
    

    <title>
        
          Kotlin协程教程（1）：启动 - Hexo
        
    </title>

    <!-- Spectre.css framework (v0.5.8) -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- Noto Sans TC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">
    <!-- Noto Sans SC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
    <!-- Noto Sans -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">

    <!-- theme css & js -->
    <link rel="stylesheet" href="/css/spectre_custom.css">
    <link rel="stylesheet" href="/css/book.css">
    <script src="/js/book.js"></script>

    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
</head>

<body>

<div class="container">
  <div class="book-container">
    <div class="columns">
      <div class="column col-2 hide-lg">
        <div class="book-sidebar">
  <h4 class="site-meta">
    <a href="/">Hexo</a>
  </h4>
  <div class="sidebar-content">
    
  </div>
</div>

<script src="/js/book-sidebar.js"></script>
      </div>

      <div class="column col-8 col-lg-12">
        <div class="book-content">
          <div class="book-navbar">
  <header class="navbar">
  <section class="navbar-section">
    <img class="navbar-icon" src="/favicon.ico">
  </section>
  <section class="navbar-center">
    Hexo
  </section>
  <section class="navbar-section">
    <label class="accordion-header c-hand" for="accordion-sidebar">
      <i class="icon icon-menu"></i>
    </label>
  </section>
</header>

<div class="accordion">
  <input type="checkbox" id="accordion-sidebar" name="accordion-checkbox" hidden>
  <div class="accordion-body">
    
  </div>
</div>
</div>

<div class="book-post">
  <h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程简单的来说，就是用户态的线程。</p>
<p>emmm，还是不明白对吧，那想象一个这样的场景，如果在一个单核的机器上有两个线程需要执行，因为一次只能执行一个线程里面的代码，那么就会出现线程切换的情况，一会需要执行一下线程A，一会需要执行一下线程B，线程切换会带来一些开销。</p>
<p>假设两个线程，交替执行，如下图所示<br><img src="evernotecid://944EA088-8890-4EBF-B23B-C680C79495A2/appyinxiangcom/1072265/ENResource/p368" alt="f5586296599855f205be7893ea2b27c3.png"></p>
<p>线程会因为Thread.sleep方法而进入阻塞状态（就是什么也不会执行），这样多浪费资源啊。</p>
<p>能不能将代码块打包成一个个小小的可执行片段，由一个统一的分配器去分配到线程上去执行呢，如果我的代码块里要求sleep一会，那么就去执行别的代码块，等会再来执行我呢。<br><img src="evernotecid://944EA088-8890-4EBF-B23B-C680C79495A2/appyinxiangcom/1072265/ENResource/p369" alt="1731a54d1f50c900513aca960196e98c.png"></p>
<p>协程就是这样一个东西，我们作为使用者不需要再去考虑创建一个新线程去执行一坨代码，也不需要关心线程怎么管理。我们需要关心的是，我要异步的执行一坨代码，待会我要拿到它的结果，我要异步的执行很多坨代码，待会我要按某种顺序，或者某种逻辑得到它们的结果。</p>
<p>总而言之，协程是用户态的线程，它是在用户态实现的一套机制，可以避免线程切换带来的开销，可以高效的利用线程的资源。</p>
<p>从代码上来讲，也可以更漂亮的写各种异步逻辑。</p>
<p>这里想再讲讲一个概念，阻塞与非阻塞是什么意思</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>简单来说，阻塞就是不执行了，非阻塞就是一直在执行。<br>比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.wait() <span class="comment">// 阻塞了</span></span><br><span class="line"><span class="comment">// 这里执行不到了</span></span><br></pre></td></tr></table></figure>

<p>但是，如果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 一直在运行，没有阻塞</span></span><br><span class="line">   i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里也执行不到了</span></span><br></pre></td></tr></table></figure>

<h2 id="runBlocking：连接阻塞与非阻塞的世界"><a href="#runBlocking：连接阻塞与非阻塞的世界" class="headerlink" title="runBlocking：连接阻塞与非阻塞的世界"></a>runBlocking：连接阻塞与非阻塞的世界</h2><p>runBlocking是启动新协程的一种方法。</p>
<p>runBlocking启动一个新的协程，并阻塞它的调用线程，直到里面的代码执行完毕。</p>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"aaaaaaaaa <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">runBlocking &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(<span class="string">"bbbbbbbbb <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码的输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaa main</span><br><span class="line">0 main</span><br><span class="line">1 main</span><br><span class="line">2 main</span><br><span class="line">3 main</span><br><span class="line">4 main</span><br><span class="line">5 main</span><br><span class="line">6 main</span><br><span class="line">7 main</span><br><span class="line">8 main</span><br><span class="line">9 main</span><br><span class="line">10 main</span><br><span class="line">bbbbbbbbb main</span><br></pre></td></tr></table></figure>

<p>emmm，这并没有什么稀奇，所有的代码都在主线程执行，按照顺序来，去掉runBlocking也是一样的嘛。</p>
<p>但是，runBlocking可以指定参数，就可以让runBlocking里面的代码在其他线程执行，但同样可以阻塞外部线程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"aaaaaaaaa <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">runBlocking(Dispatchers.IO) &#123; <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(<span class="string">"bbbbbbbbb <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码，给runBlocking添加了一个参数，Dispatchers.IO，这样里面的代码块就会执行到其他线程了。</p>
<p>来一起看看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaa main</span><br><span class="line">0 DefaultDispatcher-worker-1</span><br><span class="line">1 DefaultDispatcher-worker-1</span><br><span class="line">2 DefaultDispatcher-worker-1</span><br><span class="line">3 DefaultDispatcher-worker-4</span><br><span class="line">4 DefaultDispatcher-worker-4</span><br><span class="line">5 DefaultDispatcher-worker-6</span><br><span class="line">6 DefaultDispatcher-worker-7</span><br><span class="line">7 DefaultDispatcher-worker-7</span><br><span class="line">8 DefaultDispatcher-worker-9</span><br><span class="line">9 DefaultDispatcher-worker-1</span><br><span class="line">10 DefaultDispatcher-worker-5</span><br><span class="line">bbbbbbbbb main</span><br></pre></td></tr></table></figure>

<p>通过断点在runBlocking里面的代码，查看这个时候，主线程是什么状态，发现它是进入了WAIT态。<br><img src="evernotecid://944EA088-8890-4EBF-B23B-C680C79495A2/appyinxiangcom/1072265/ENResource/p367" alt="4e2c64f0f3337e7008c151b06493abf3.png"></p>
<p>当给runBlocking指定Dispatchers参数时，就仿佛是使用了join方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = thread &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure>

<h2 id="launch：启动一个协程"><a href="#launch：启动一个协程" class="headerlink" title="launch：启动一个协程"></a>launch：启动一个协程</h2><p>launch可以启动一个协程，但不会阻塞调用线程，但是launch必须要在<strong>协程作用域</strong>中才能调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// no, no, no...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">// is ok</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要在非协程作用域调用launch，可以使用GlobalScope.launch。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="comment">// is ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的launch也是可以传入一个Dispatcher参数来指定它会被分配到什么线程上执行。</p>
<p>此时，大家就会想了，GlobalScope.launch那么方便，是不是只用它就行了？什么时候该用launch，什么时候该用GlobalScope.launch呢？</p>
<p>文档这样说道：GlobalScope.launch会启动一个top-level的协程，它的生命周期将只受到整个应用程序生命周期的限制。</p>
<p>emmmm，那是不是说，普通的launch，它所创建的协程会受到外层的一个作用域的生命周期的影响，而GlobalScope所创建的协程，不收外层的影响。</p>
<p>于是，有了下面的实验</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    runBlocking(Dispatchers.IO) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job = launch &#123; <span class="comment">// 外层任务，包裹两个协程</span></span><br><span class="line"></span><br><span class="line">            GlobalScope.launch &#123; <span class="comment">// 第一个协程</span></span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">                    println(<span class="string">"GlobalScope <span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span> -----"</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            launch &#123; <span class="comment">// 第二个协程</span></span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">                    println(<span class="string">"normal launch <span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span> #####"</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">300</span>); <span class="comment">// 延迟一会，让第二个协程能执行3次左右</span></span><br><span class="line"></span><br><span class="line">        job.cancel() <span class="comment">// 将外层任务取消了</span></span><br><span class="line"></span><br><span class="line">        delay(<span class="number">2000</span>) <span class="comment">// 继续延迟，期望看到GlobalScope能继续运行</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看实验结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope 0 DefaultDispatcher-worker-2 -----</span><br><span class="line">normal launch 0 DefaultDispatcher-worker-5 #####</span><br><span class="line">GlobalScope 1 DefaultDispatcher-worker-5 -----</span><br><span class="line">normal launch 1 DefaultDispatcher-worker-1 #####</span><br><span class="line">GlobalScope 2 DefaultDispatcher-worker-5 -----</span><br><span class="line">normal launch 2 DefaultDispatcher-worker-3 #####</span><br><span class="line">GlobalScope 3 DefaultDispatcher-worker-7 -----</span><br><span class="line">GlobalScope 4 DefaultDispatcher-worker-8 -----</span><br><span class="line">GlobalScope 5 DefaultDispatcher-worker-8 -----</span><br><span class="line">GlobalScope 6 DefaultDispatcher-worker-7 -----</span><br><span class="line">GlobalScope 7 DefaultDispatcher-worker-1 -----</span><br><span class="line">GlobalScope 8 DefaultDispatcher-worker-3 -----</span><br><span class="line">GlobalScope 9 DefaultDispatcher-worker-9 -----</span><br><span class="line">GlobalScope 10 DefaultDispatcher-worker-5 -----</span><br></pre></td></tr></table></figure>

<p>如我的预料一样，GlobalScope无法被cancel。</p>
<p>再来看一下文档里面怎么描述的，体会一下：</p>
<blockquote>
<p>Global scope is used to launch top-level coroutines which are operating on the whole application lifetime<br>and are not cancelled prematurely.</p>
</blockquote>
<p>接下来，解释一下上面提到的协程作用域的概念。</p>
<h2 id="什么是协程作用域（Coroutine-Scope）？"><a href="#什么是协程作用域（Coroutine-Scope）？" class="headerlink" title="什么是协程作用域（Coroutine Scope）？"></a>什么是协程作用域（Coroutine Scope）？</h2><p>协程作用域是协程运行的作用范围，换句话说，如果这个作用域销毁了，那么里面的协程也随之失效。就好比变量的作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// scope start</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">&#125; <span class="comment">// scope end</span></span><br><span class="line">println(a); <span class="comment">// what is a?</span></span><br></pre></td></tr></table></figure>

<p>协程作用域也是这样一个作用，可以用来确保里面的协程都有一个作用域的限制。</p>
<p>一个经典的示例就是，比如我们要在Android上使用协程，但是我们不希望Activity销毁了，我的协程还在悄咪咪的干一些事情，我希望它能停止掉。</p>
<p>我们就可以</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，里面运行的协程就会随着Activity的销毁而销毁。</p>
<h2 id="launch的返回值：Job"><a href="#launch的返回值：Job" class="headerlink" title="launch的返回值：Job"></a>launch的返回值：Job</h2><p>回到launch的话题，launch启动后，会返回一个Job对象，表示这个启动的协程，我们可以方便的通过这个Job对象，取消，等待这个协程。</p>
<p>像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    runBlocking(Dispatchers.IO) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">                println(<span class="string">"normal launch <span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span> #####"</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">                println(<span class="string">"normal launch <span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span> -----"</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job1.join()</span><br><span class="line">        job2.join()</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"all job finished"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用job的join方法，来等待这个协程执行完毕。这个和Thread的join方法语义一样。</p>
<h2 id="async：启动协程的另一种姿势"><a href="#async：启动协程的另一种姿势" class="headerlink" title="async：启动协程的另一种姿势"></a>async：启动协程的另一种姿势</h2><p>launch启动一个协程后，会返回一个Job对象，这个Job对象不含有任何数据，它只是表示启动的协程本身，我们可以通过这个Job对象来对协程进行控制。</p>
<p>假设这样一种场景，我需要同时启动两个协程来搞点事，然后它们分别都会计算出一个Int值，当两个协程都做完了之后，我需要将这两个Int值加在一起并输出。</p>
<p>如果使用launch，我们可能要在外层建立一个变量来记录协程的输出数据了，但是使用async，就可以轻松的解决这个问题！</p>
<p>async的返回值依然是个Job对象，但它可以带上返回值。</p>
<p>上面的小需求可以用下面的代码实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    runBlocking(Dispatchers.IO) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job1 = async &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">                println(<span class="string">"normal launch <span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span> #####"</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="number">10</span> <span class="comment">// 注意这里的返回值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job2 = async &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">                println(<span class="string">"normal launch <span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span> -----"</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="number">20</span> <span class="comment">// 注意这里的返回值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(job1.await() + job2.await())</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"all job finished"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了await方法来获取返回值，它会等待协程执行完毕，并将返回值吐出来。</p>
<p>这样上面的代码就是两个协程自己吭哧吭哧弄完之后，各自返回了10和20，外层再将它们加起来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章，我大概的讲了一下协程的概念和被发明的初衷，以及在kotlin中，启动协程的基本方法，最后再总结一下，方便快速复习。</p>
<p>进程是一个应用程序的资源管理单元，线程是一个执行单元，但当线程这个执行单元需要切换状态，停止，启动，或者大量启动的时候，就会比较消耗资源。我们需要一个更轻巧，更容易被控制的执行单元，这就是协程啦。</p>
<p>本篇介绍了runBlocking方法，它可以在非协程作用域下创建一个协程作用域，它的名字也很好，阻塞的执行，意味着，它会阻塞它的调用线程，直到它内部都执行完毕。</p>
<p>launch和async都可以在协程作用域下启动协程，launch以Job对象的形式返回协程任务本身，可以通过Job来操作协程，async以Deferred对象的形式返回协程任务，可以获取执行流的返回值。</p>
<p>GlobalScope.launch会创建一个顶层的协程，它只受限于整个应用的生命周期，不建议使用。</p>
<hr>
<p><strong>如果你喜欢这篇文章，欢迎点赞评论打赏</strong><br><strong>更多干货内容，欢迎关注我的公众号：好奇码农君</strong></p>
<p><img src="evernotecid://944EA088-8890-4EBF-B23B-C680C79495A2/appyinxiangcom/1072265/ENResource/p370" alt="879bb2d5788b223627e265631f3f582b.png"></p>

</div>


  <div class="book-comments">
    


  </div>


<script src="/js/book-post.js"></script>
        </div>
      </div>

      <div class="column col-2 hide-lg">
        <div class="book-toc">
  <div class="book-tocbot">
  </div>
  <div class="book-tocbot-menu">
    <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
    <a onclick="go_top()">Back to top</a>
    <a onclick="go_bottom()">Go to bottom</a>
  </div>
</div>

<script>
tocbot.init({
  tocSelector: '.book-tocbot',
  contentSelector: '.book-post',
  headingSelector: 'h1, h2, h3, h4, h5',
  collapseDepth: 2,
  orderedList: false,
  scrollSmooth: false,
});

function expand_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 6,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "collapse_toc()");
  b.innerHTML = "Collapse all"
}

function collapse_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 2,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "expand_toc()");
  b.innerHTML = "Expand all"
}

function go_top() {
  window.scrollTo(0, 0);
}

function go_bottom() {
  window.scrollTo(0, document.body.scrollHeight);
}

</script>
      </div>
    </div>
  </div>
</div>

</body>
</html>
